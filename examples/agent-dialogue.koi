package "agent-dialogue"

role Worker { can execute }
role Coordinator { can execute, can delegate }

Team TestTeam {
  philosopher = Philosopher
  poet = Poet
}

// Agente Fil√≥sofo que hace preguntas profundas
Agent Philosopher : Worker {
  llm default = { provider: "openai", model: "gpt-5.2" }

  on ask(args: Json) {
    playbook """
    Eres un fil√≥sofo que hace preguntas profundas.

    Contexto: ${args.context}

    Genera UNA pregunta filos√≥fica breve (m√°ximo 2 oraciones).

    Return ONLY: { "question": "tu pregunta aqu√≠" }
    """
  }
}

// Agente Poeta que responde de manera po√©tica
Agent Poet : Worker {
  llm default = { provider: "openai", model: "gpt-5.2" }

  on respond(args: Json) {
    playbook """
    Eres un poeta que responde de manera metaf√≥rica.

    Pregunta: "${args.question}"

    Responde po√©ticamente (m√°ximo 2 oraciones).

    Return ONLY: { "answer": "tu respuesta aqu√≠" }
    """
  }
}

// Coordinador que orquesta el di√°logo
Agent DialogueCoordinator : Coordinator {
  llm default = { provider: "openai", model: "gpt-5.2" }

  uses Team TestTeam

  on startDialogue(args: Json) {
    playbook """
    Coordina un di√°logo entre Fil√≥sofo y Poeta por 3 turnos.

    Use repeat action with count: 3. Inside repeat, for EACH iteration:

    EXACT STEPS (use same IDs in all iterations):
    1. Delegate to Philosopher with intent "ask", data: { context: "" }, store with id "q"
    2. Delegate to Poet with intent "respond", data: { question: "${q.output.question}" }, store with id "a"
    3. Print dialogue (Philosopher's question has field "question", Poet's answer has field "answer"):
       - ü§î Fil√≥sofo: ${q.output.question}
       - üé≠ Poeta: ${a.output.answer}

    CRITICAL: Inside repeat, each iteration has its own context. Use same IDs (q, a) in each iteration.
    The repeat action will handle context scoping automatically.

    After the repeat completes, print:
    ‚ú® Di√°logo completado!
    """
  }
}

run DialogueCoordinator.startDialogue({})
