/**
 * SessionTracker - Git-based session change tracking with navigable history.
 *
 * Uses a separate GIT_DIR per session so we don't interfere with
 * the project's own .git. The working tree is the project root.
 *
 * Architecture:
 *   - trackFile() stages files (git add) but does NOT commit
 *   - commitChanges(summary) commits all staged files as one changeset
 *   - The agent calls commitChanges() after each prompt execution
 *   - getHistory() returns the full commit log with summaries + timestamps
 *   - checkoutCommit(hash) syncs working tree to any point in history
 *
 * Lazy-initialized: git repo is only created on the first file change.
 * Non-fatal: git failures never break actual file edits.
 */

import { execFileSync } from 'child_process';
import path from 'path';
import fs from 'fs';
import { cliLogger } from './cli-logger.js';

export class SessionTracker {
  constructor(sessionId, projectRoot) {
    this.sessionId = sessionId;
    this.projectRoot = projectRoot;
    this.gitDir = path.join(projectRoot, '.koi', 'sessions', sessionId);
    this.initialized = false;
    this.trackedFiles = new Set();
    this.pendingFiles = new Set(); // files staged but not yet committed
  }

  /** Run git with GIT_DIR/GIT_WORK_TREE pointing to our session repo.
   *  Uses execFileSync (no shell) to avoid pipe/special char issues. */
  _git(args, { noWorkTree = false } = {}) {
    const env = { ...process.env, GIT_DIR: this.gitDir };
    if (!noWorkTree) env.GIT_WORK_TREE = this.projectRoot;
    // Split args respecting quoted strings
    const argv = args.match(/(?:[^\s"]+|"[^"]*")+/g).map(a => a.replace(/^"|"$/g, ''));
    return execFileSync('git', argv, {
      cwd: this.projectRoot,
      env,
      encoding: 'utf8',
      stdio: ['pipe', 'pipe', 'pipe']
    }).trim();
  }

  /** Initialize the session git repo (lazy, on first file change or query) */
  _ensureInit() {
    if (this.initialized) return;

    const repoExists = fs.existsSync(path.join(this.gitDir, 'HEAD'));

    if (repoExists) {
      // Resuming an existing session — recover tracked files from git history
      this.initialized = true;
      try {
        const files = this._git('log --all --format= --name-only');
        if (files) {
          for (const f of files.split('\n').filter(Boolean)) {
            this.trackedFiles.add(f);
          }
        }
      } catch { /* non-fatal */ }
      cliLogger.log('session', `Resumed session tracker: ${this.sessionId} (${this.trackedFiles.size} files)`);
    } else {
      // New session — create bare repo with empty initial commit
      fs.mkdirSync(this.gitDir, { recursive: true });
      this._git('init --bare', { noWorkTree: true });
      this._git('config user.email "koi-session@local"');
      this._git('config user.name "Koi Session"');
      this._git('commit --allow-empty -m "session start"');
      this.initialized = true;
      cliLogger.log('session', `Initialized session tracker: ${this.sessionId}`);
    }
  }

  /**
   * Stage a file change. Called by edit-file/write-file after successful write.
   * On first track of a file, stages oldContent as a baseline so diffs show
   * actual changes instead of "new file mode".
   * Does NOT commit — call commitChanges() after all actions in a prompt are done.
   */
  trackFile(filePath, oldContent) {
    try {
      this._ensureInit();
      const resolved = path.resolve(filePath);
      const relative = path.relative(this.projectRoot, resolved);

      // First time tracking: commit old content as baseline (silent, not a user-visible changeset)
      if (!this.trackedFiles.has(relative) && oldContent !== undefined) {
        const tmpFile = path.join(this.gitDir, 'tmp-baseline');
        fs.writeFileSync(tmpFile, oldContent, 'utf8');
        const hash = this._git(`hash-object -w "${tmpFile}"`).trim();
        fs.unlinkSync(tmpFile);
        this._git(`update-index --add --cacheinfo 100644,${hash},${relative}`);
        this._git(`commit -m "baseline: ${relative}" --allow-empty`);
      }

      this.trackedFiles.add(relative);
      this.pendingFiles.add(relative);
      this._git(`add "${relative}"`);
      cliLogger.log('session', `Staged: ${relative}`);
    } catch (err) {
      cliLogger.log('session', `Stage failed: ${err.message}`);
    }
  }

  /**
   * Commit all staged (pending) files as a single changeset.
   * @param {string} summary - Natural language description of the changes (LLM-generated)
   * @returns {{ success: boolean, hash?: string, files?: string[] }}
   */
  commitChanges(summary) {
    if (!this.initialized || this.pendingFiles.size === 0) {
      return { success: false, reason: 'nothing to commit' };
    }
    try {
      // Check if there are actual staged changes
      const staged = this._git('diff --cached --name-only');
      if (!staged) {
        this.pendingFiles.clear();
        return { success: false, reason: 'nothing to commit' };
      }

      const message = summary || `Changed: ${[...this.pendingFiles].join(', ')}`;
      this._git(`commit -m "${message.replace(/"/g, '\\"')}"`);
      const hash = this._git('rev-parse --short HEAD');
      const files = [...this.pendingFiles];
      this.pendingFiles.clear();

      cliLogger.log('session', `Committed [${hash}]: ${message}`);
      return { success: true, hash, files };
    } catch (err) {
      cliLogger.log('session', `Commit failed: ${err.message}`);
      return { success: false, reason: err.message };
    }
  }

  /** Check if there are pending (staged but uncommitted) file changes */
  hasPendingChanges() {
    return this.pendingFiles.size > 0;
  }

  // ─── Diff Methods ────────────────────────────────────────────────────

  /**
   * Find the baseline commit for a file (first commit that introduced it).
   */
  _findBaseline(relative) {
    try {
      const commits = this._git(`log --format=%H --reverse -- "${relative}"`);
      const list = commits.split('\n').filter(Boolean);
      return list.length > 0 ? list[0] : null;
    } catch {
      return null;
    }
  }

  /**
   * Get cumulative diff of all changes in this session.
   * Per-file: diffs from each file's baseline commit to HEAD.
   */
  getDiff() {
    this._ensureInit();
    try {
      const parts = [];
      for (const file of this.trackedFiles) {
        const baseline = this._findBaseline(file);
        if (!baseline) continue;
        const fileDiff = this._git(`diff ${baseline} HEAD -- "${file}"`);
        if (fileDiff) parts.push(fileDiff);
      }
      return parts.length > 0 ? parts.join('\n') : '(no changes)';
    } catch {
      return '(no changes)';
    }
  }

  /** Get list of changed files */
  getChangedFiles() {
    this._ensureInit();
    const changed = [];
    for (const file of this.trackedFiles) {
      try {
        const baseline = this._findBaseline(file);
        if (!baseline) continue;
        const diff = this._git(`diff --name-only ${baseline} HEAD -- "${file}"`);
        if (diff) changed.push(file);
      } catch { /* skip */ }
    }
    return changed;
  }

  /**
   * Get diff for a single file from the session.
   * @param {boolean} reverse - If true, show reverse diff (what a revert would look like)
   */
  getFileDiff(filePath, reverse = false) {
    this._ensureInit();
    try {
      const resolved = path.resolve(filePath);
      const relative = path.relative(this.projectRoot, resolved);
      const baseline = this._findBaseline(relative);
      if (!baseline) return '(no changes for this file)';
      const [from, to] = reverse ? ['HEAD', baseline] : [baseline, 'HEAD'];
      return this._git(`diff ${from} ${to} -- "${relative}"`);
    } catch {
      return '(no changes for this file)';
    }
  }

  // ─── History Methods ─────────────────────────────────────────────────

  /**
   * Get full commit history (excluding baselines and session start).
   * Returns array of { hash, shortHash, summary, date, files }
   * Most recent first.
   */
  getHistory() {
    this._ensureInit();
    try {
      // Format: hash|short|date|subject — most recent first (default git log order)
      const log = this._git('log --format=%H|%h|%aI|%s');
      if (!log) return [];

      return log.split('\n')
        .filter(Boolean)
        .map(line => {
          const [hash, shortHash, date, ...rest] = line.split('|');
          const summary = rest.join('|'); // summary might contain |
          return { hash, shortHash, summary, date };
        })
        // Exclude baseline commits and session start — only user-visible changesets
        .filter(c => !c.summary.startsWith('baseline:') && c.summary !== 'session start');
    } catch {
      return [];
    }
  }

  /**
   * Get diff between two commits (e.g. to show what a specific changeset did).
   */
  getCommitDiff(commitHash) {
    this._ensureInit();
    try {
      return this._git(`diff ${commitHash}~1 ${commitHash}`);
    } catch {
      return '(no changes)';
    }
  }

  /**
   * Checkout a specific commit — sync working tree files to that point in history.
   * Does NOT create a new commit. Only restores tracked files in the working tree.
   * New commits are only created when the user makes actual new changes.
   */
  checkoutCommit(commitHash) {
    this._ensureInit();
    try {
      const targetSummary = this._git(`log --format=%s -1 ${commitHash}`);

      // Only restore files that are tracked by this session
      for (const file of this.trackedFiles) {
        try {
          // Try to get this file's content from the target commit
          this._git(`show ${commitHash}:"${file}"`)
          // File exists in target commit — restore it
          this._git(`checkout ${commitHash} -- "${file}"`);
        } catch {
          // File doesn't exist in target commit — check if it's a baseline-only file
          // (was added AFTER this commit). Restore to its baseline state.
          try {
            const baseline = this._findBaseline(file);
            if (baseline) {
              this._git(`checkout ${baseline} -- "${file}"`);
            }
          } catch { /* leave file as-is if baseline also fails */ }
        }
      }

      // Reset HEAD to target commit without affecting working tree (soft reset)
      this._git(`reset --soft ${commitHash}`);

      return {
        success: true,
        restoredTo: commitHash,
        files: [...this.trackedFiles],
        summary: targetSummary
      };
    } catch (err) {
      return { success: false, error: err.message };
    }
  }

  /** Get current HEAD hash */
  getHead() {
    this._ensureInit();
    try {
      return this._git('rev-parse HEAD');
    } catch {
      return null;
    }
  }

  /** Get commit log (list of edits) */
  getLog() {
    this._ensureInit();
    try {
      return this._git('log --oneline --reverse');
    } catch {
      return '(no changes)';
    }
  }

  // ─── Input History Persistence ──────────────────────────────────────

  /** Save input history entries to disk */
  saveInputHistory(entries) {
    try {
      const filePath = path.join(this.gitDir, 'input-history.json');
      fs.writeFileSync(filePath, JSON.stringify(entries), 'utf8');
    } catch { /* non-fatal */ }
  }

  /** Load input history entries from disk */
  loadInputHistory() {
    try {
      const filePath = path.join(this.gitDir, 'input-history.json');
      if (!fs.existsSync(filePath)) return [];
      return JSON.parse(fs.readFileSync(filePath, 'utf8'));
    } catch {
      return [];
    }
  }

  // ─── Dialogue Log ─────────────────────────────────────────────────

  /** Append a dialogue entry to the JSONL log */
  appendDialogue(entry) {
    try {
      this._ensureInit();
      const filePath = path.join(this.gitDir, 'dialogue.jsonl');
      fs.appendFileSync(filePath, JSON.stringify(entry) + '\n', 'utf8');
    } catch { /* non-fatal */ }
  }

  /** Load last N dialogue entries */
  loadDialogue(limit = 20) {
    try {
      const filePath = path.join(this.gitDir, 'dialogue.jsonl');
      if (!fs.existsSync(filePath)) return [];
      const lines = fs.readFileSync(filePath, 'utf8').trim().split('\n').filter(Boolean);
      return lines.slice(-limit).map(l => JSON.parse(l));
    } catch {
      return [];
    }
  }

  // ─── Commit Embeddings ────────────────────────────────────────────

  /** Save a commit embedding to the index */
  saveCommitEmbedding(hash, summary, embedding) {
    try {
      const filePath = path.join(this.gitDir, 'commit-embeddings.json');
      let data = { commits: {} };
      if (fs.existsSync(filePath)) {
        data = JSON.parse(fs.readFileSync(filePath, 'utf8'));
      }
      data.commits[hash] = { summary, embedding, date: new Date().toISOString() };
      fs.writeFileSync(filePath, JSON.stringify(data), 'utf8');
    } catch { /* non-fatal */ }
  }

  /** Load all commit embeddings */
  loadCommitEmbeddings() {
    try {
      const filePath = path.join(this.gitDir, 'commit-embeddings.json');
      if (!fs.existsSync(filePath)) return { commits: {} };
      return JSON.parse(fs.readFileSync(filePath, 'utf8'));
    } catch {
      return { commits: {} };
    }
  }

  // ─── Conversation Persistence ──────────────────────────────────────

  /** Save conversation history for an agent */
  saveConversation(agentName, messages) {
    try {
      this._ensureInit();
      const filePath = path.join(this.gitDir, `conversation-${agentName}.json`);
      fs.writeFileSync(filePath, JSON.stringify(messages), 'utf8');
    } catch { /* non-fatal */ }
  }

  /** Load conversation history for an agent */
  loadConversation(agentName) {
    try {
      const filePath = path.join(this.gitDir, `conversation-${agentName}.json`);
      if (!fs.existsSync(filePath)) return [];
      return JSON.parse(fs.readFileSync(filePath, 'utf8'));
    } catch {
      return [];
    }
  }

  /** Cosine similarity between two vectors */
  static cosineSimilarity(a, b) {
    let dot = 0, magA = 0, magB = 0;
    for (let i = 0; i < a.length; i++) {
      dot += a[i] * b[i];
      magA += a[i] * a[i];
      magB += b[i] * b[i];
    }
    return dot / (Math.sqrt(magA) * Math.sqrt(magB));
  }

  /** Undo last changeset (revert last commit, restore files to previous state) */
  undo() {
    this._ensureInit();
    try {
      const commitCount = parseInt(this._git('rev-list --count HEAD'), 10);
      if (commitCount <= 1) return { success: false, error: 'No changes to undo' };

      // Get list of files changed in the last commit
      const lastFiles = this._git('diff --name-only HEAD~1 HEAD');
      const files = lastFiles ? lastFiles.split('\n').filter(Boolean) : [];

      // Restore only those specific files to their previous state
      for (const file of files) {
        try {
          this._git(`checkout HEAD~1 -- "${file}"`);
        } catch { /* file might not exist in previous commit */ }
      }

      // Move HEAD back
      this._git('reset --soft HEAD~1');

      return {
        success: true,
        reverted: files,
        message: 'Last changeset reverted'
      };
    } catch (err) {
      return { success: false, error: err.message };
    }
  }
}

// Singleton — set during koi run
export let sessionTracker = null;

export function initSessionTracker(sessionId, projectRoot) {
  sessionTracker = new SessionTracker(sessionId, projectRoot);
  return sessionTracker;
}
